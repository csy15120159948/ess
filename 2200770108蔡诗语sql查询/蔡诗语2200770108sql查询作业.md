# 练习
1. 查询所有员工的姓名、邮箱和工作岗位。

       SELECT CONCAT(first_name, ' ', last_name) AS full_name, email, job_title
       FROM employees;

2. 查询所有部门的名称和位置。

       SELECT dept_name, location
       FROM departments;
3. 查询工资超过70000的员工姓名和工资。

       SELECT CONCAT(first_name, ' ', last_name) AS full_name, salary
       FROM employees
       WHERE salary > 70000;
4. 查询IT部门的所有员工。

        SELECT e.emp_id, e.first_name, e.last_name, e.email, e.phone_number, e.hire_date, e.job_title, e.salary
        FROM employees e
        JOIN departments d ON e.dept_id = d.dept_id
        WHERE d.dept_name = 'IT';
5. 查询入职日期在2020年之后的员工信息。

        SELECT emp_id, first_name, last_name, email, phone_number, hire_date, job_title, salary, dept_id
        FROM employees
        WHERE hire_date > '2020-01-01';
6. 计算每个部门的平均工资。

        SELECT d.dept_name, AVG(e.salary) AS average_salary
        FROM departments d
        JOIN employees e ON d.dept_id = e.dept_id
        GROUP BY d.dept_id, d.dept_name;
7. 查询工资最高的前3名员工信息。

        SELECT emp_id, first_name, last_name, email, phone_number, hire_date, job_title, salary, dept_id
        FROM employees
        ORDER BY salary DESC
        LIMIT 3;
8. 查询每个部门员工数量。

        SELECT d.dept_name, COUNT(e.emp_id) AS employee_count
        FROM departments d
        LEFT JOIN employees e ON d.dept_id = e.dept_id
        GROUP BY d.dept_id, d.dept_name;
9. 查询没有分配部门的员工。

        SELECT emp_id, first_name, last_name, email, phone_number, hire_date, job_title, salary
        FROM employees
        WHERE dept_id IS NULL;
10. 查询参与项目数量最多的员工。

        SELECT e.emp_id, e.first_name, e.last_name, COUNT(ep.project_id) AS project_count
        FROM employees e
        JOIN employee_projects ep ON e.emp_id = ep.emp_id
        GROUP BY e.emp_id, e.first_name, e.last_name
        ORDER BY project_count DESC
        LIMIT 1;
11. 计算所有员工的工资总和。

        SELECT SUM(salary) AS total_salary
        FROM employees;
12. 查询姓"Smith"的员工信息。

        SELECT emp_id, first_name, last_name, email, phone_number, hire_date, job_title, salary, dept_id
        FROM employees
        WHERE last_name = 'Smith';
13. 查询即将在半年内到期的项目。

        SELECT *
        FROM projects
        WHERE due_date >= DATE_SUB(CURRENT_DATE, INTERVAL 6 MONTH)
        AND due_date <= CURRENT_DATE;
14. 查询至少参与了两个项目的员工。

        SELECT e.emp_id, e.first_name, e.last_name, COUNT(ep.project_id) AS project_count
        FROM employees e
        JOIN employee_projects ep ON e.emp_id = ep.emp_id
        GROUP BY e.emp_id, e.first_name, e.last_name
        HAVING project_count >= 2;
15. 查询没有参与任何项目的员工。

        SELECT e.emp_id, e.first_name, e.last_name, e.email, e.phone_number, e.hire_date, e.job_title, e.salary, e.dept_id
        FROM employees e
        LEFT JOIN employee_projects ep ON e.emp_id = ep.emp_id
        WHERE ep.emp_id IS NULL;
16. 计算每个项目参与的员工数量。

        SELECT p.project_id, p.project_name, COUNT(ep.emp_id) AS employee_count
        FROM projects p
        LEFT JOIN employee_projects ep ON p.project_id = ep.project_id
        GROUP BY p.project_id, p.project_name;
17. 查询工资第二高的员工信息。

        SELECT e.emp_id, e.salary, e.last_name, e.first_name
        FROM employees e
        JOIN salaries s ON e.emp_id = s.emp_id
        WHERE s.salary = (
        SELECT DISTINCT salary
        FROM salaries
        ORDER BY salary DESC
        LIMIT 1, 1
        );
18. 查询每个部门工资最高的员工。

        SELECT e.emp_id, e.first_name, e.last_name, e.salary, d.dept_name
        FROM employees e
        JOIN departments d ON e.dept_id = d.dept_id
        WHERE (e.dept_id, e.salary) IN (
        SELECT dept_id, MAX(salary)
        FROM employees
        GROUP BY dept_id
        );
19. 计算每个部门的工资总和,并按照工资总和降序排列。

        SELECT d.dept_name, SUM(e.salary) AS total_salary
        FROM departments d
        JOIN employees e ON d.dept_id = e.dept_id
        GROUP BY d.dept_id, d.dept_name
        ORDER BY total_salary DESC;
20. 查询员工姓名、部门名称和工资。

        SELECT CONCAT(e.first_name, ' ', e.last_name) AS employee_name, d.dept_name, e.salary
        FROM employees e
        JOIN departments d ON e.dept_id = d.dept_id;
21. 查询每个员工的上级主管(假设emp_id小的是上级)。

        SELECT e.emp_id, e.first_name, e.last_name, m.emp_id AS manager_id, m.first_name AS manager_first_name, m.last_name AS manager_last_name
        FROM employees e
        LEFT JOIN employees m ON e.manager_id = m.emp_id
        ORDER BY e.emp_id;
22. 查询所有员工的工作岗位,不要重复。

        SELECT DISTINCT job_title
        FROM employees;
23. 查询平均工资最高的部门。

        SELECT d.dept_name, AVG(e.salary) AS average_salary
        FROM departments d
        JOIN employees e ON d.dept_id = e.dept_id
        GROUP BY d.dept_id, d.dept_name
        ORDER BY average_salary DESC
        LIMIT 1;
24. 查询工资高于其所在部门平均工资的员工。

        SELECT e.emp_id, e.first_name, e.last_name, e.salary, d.dept_name
        FROM employees e
        JOIN departments d ON e.dept_id = d.dept_id
        WHERE e.salary > (
        SELECT AVG(salary)
        FROM employees
        WHERE dept_id = e.dept_id
        );
25. 查询每个部门工资前两名的员工。

        WITH RankedEmployees AS (
        SELECT
        e.emp_id,
        e.first_name,
        e.last_name,
        e.salary,
        d.dept_name,
        RANK() OVER (PARTITION BY d.dept_id ORDER BY e.salary DESC) AS salary_rank
        FROM employees e
        JOIN departments d ON e.dept_id = d.dept_id
        )
        SELECT emp_id, first_name, last_name, salary, dept_name
        FROM RankedEmployees
        WHERE salary_rank <= 2;
26. 查询跨部门的项目(参与员工来自不同部门)。

        SELECT p.project_id, p.project_name
        FROM projects p
        WHERE p.project_id IN (
        SELECT ep.project_id
        FROM employee_projects ep
        JOIN employees e1 ON ep.emp_id = e1.emp_id
        JOIN employees e2 ON ep.emp_id = e2.emp_id AND e1.dept_id <> e2.dept_id
        );
27. 查询每个员工的工作年限,并按工作年限降序排序。

        SELECT
        emp_id,
        first_name,
        last_name,
        TIMESTAMPDIFF(YEAR, hire_date, CURDATE()) AS years_of_service
        FROM
        employees
        ORDER BY
        years_of_service DESC;
28. 查询本月过生日的员工(假设hire_date是生日)。

        SELECT emp_id, first_name, last_name, hire_date
        FROM employees
        WHERE MONTH(hire_date) = MONTH(CURDATE()) AND DAY(hire_date) <= DAY(LAST_DAY(CURDATE()));
29. 查询即将在90天内到期的项目和负责该项目的员工。

        SELECT p.project_id, p.project_name, e.emp_id, e.first_name, e.last_name
        FROM projects p
        JOIN employee_projects ep ON p.project_id = ep.project_id
        JOIN employees e ON ep.emp_id = e.emp_id
        WHERE p.due_date >= CURDATE() AND p.due_date <= CURDATE() + INTERVAL 90 DAY;
30. 计算每个项目的持续时间(天数)。

        SELECT
        project_id,
        project_name,
        DATEDIFF(end_date, start_date) AS duration_days
        FROM
        projects;
31. 查询没有进行中项目的部门。

        SELECT d.dept_id, d.dept_name
        FROM departments d
        WHERE NOT EXISTS (
        SELECT 1
        FROM projects p
        JOIN employee_projects ep ON p.project_id = ep.project_id
        JOIN employees e ON ep.emp_id = e.emp_id
        WHERE e.dept_id = d.dept_id
        );
32. 查询员工数量最多的部门。

        SELECT d.dept_name, COUNT(e.emp_id) AS employee_count
        FROM departments d
        JOIN employees e ON d.dept_id = e.dept_id
        GROUP BY d.dept_id, d.dept_name
        ORDER BY employee_count DESC
        LIMIT 1;
33. 查询参与项目最多的部门。

        SELECT d.dept_name, COUNT(DISTINCT p.project_id) AS project_count
        FROM departments d
        JOIN employees e ON d.dept_id = e.dept_id
        JOIN employee_projects ep ON e.emp_id = ep.emp_id
        JOIN projects p ON ep.project_id = p.project_id
        GROUP BY d.dept_id, d.dept_name
        ORDER BY project_count DESC
        LIMIT 1;
34. 计算每个员工的薪资涨幅(假设每年涨5%)。

        SELECT
        emp_id,
        first_name,
        last_name,
        salary AS original_salary,
        salary * POWER(1.05, TIMESTAMPDIFF(YEAR, hire_date, CURDATE())) AS new_salary,
        salary * POWER(1.05, TIMESTAMPDIFF(YEAR, hire_date, CURDATE())) - salary AS salary_increase
        FROM
        employees;
35. 查询入职时间最长的3名员工。

        SELECT emp_id, first_name, last_name, hire_date
        FROM employees
        ORDER BY hire_date ASC
        LIMIT 3;
36. 查询名字和姓氏相同的员工。

        SELECT emp_id, first_name, last_name
        FROM employees
        WHERE first_name = last_name;
37. 查询每个部门薪资最低的员工。

        SELECT e.emp_id, e.first_name, e.last_name, e.salary, d.dept_name
        FROM employees e
        JOIN departments d ON e.dept_id = d.dept_id
        WHERE (e.dept_id, e.salary) IN (
        SELECT dept_id, MIN(salary)
        FROM employees
        GROUP BY dept_id
        );
38. 查询哪些部门的平均工资高于公司的平均工资。

        SELECT d.dept_name
        FROM departments d
        JOIN employees e ON d.dept_id = e.dept_id
        GROUP BY d.dept_id, d.dept_name
        HAVING AVG(e.salary) > (SELECT AVG(salary) FROM employees);
39. 查询姓名包含"son"的员工信息。

        SELECT emp_id, first_name, last_name
        FROM employees
        WHERE first_name LIKE '%son%' OR last_name LIKE '%son%';
40. 查询所有员工的工资级别(可以自定义工资级别)。

        SELECT emp_id, first_name, last_name, salary,
        CASE
        WHEN salary BETWEEN 0 AND 3000 THEN '低级别'
        WHEN salary BETWEEN 3001 AND 6000 THEN '中级别'
        ELSE '高级别'
        END AS salary_level
        FROM employees;
41. 查询每个项目的完成进度(根据当前日期和项目的开始及结束日期)。

        SELECT
        project_id,
        project_name,
        start_date,
        end_date,
        DATEDIFF(CURDATE(), start_date) / DATEDIFF(end_date, start_date) * 100 AS completion_percentage
        FROM
        projects;
42. 查询每个经理(假设job_title包含'Manager'的都是经理)管理的员工数量。

        SELECT m.emp_id AS manager_id, m.first_name AS manager_first_name, m.last_name AS manager_last_name, COUNT(e.emp_id) AS employee_count
        FROM employees m
        LEFT JOIN employees e ON m.emp_id = e.manager_id
        WHERE m.job_title LIKE '%Manager%'
        GROUP BY m.emp_id, m.first_name, m.last_name;
43. 查询工作岗位名称里包含"Manager"但不在管理岗位(salary<70000)的员工。

        SELECT emp_id, first_name, last_name, job_title, salary
        FROM employees
        WHERE job_title LIKE '%Manager%' AND salary < 70000;
44. 计算每个部门的男女比例(假设以名字首字母A-M为女性,N-Z为男性)。

        SELECT d.dept_name,
        SUM(CASE WHEN SUBSTRING(e.first_name, 1, 1) BETWEEN 'A' AND 'M' THEN 1 ELSE 0 END) AS female_count,
        SUM(CASE WHEN SUBSTRING(e.first_name, 1, 1) BETWEEN 'N' AND 'Z' THEN 1 ELSE 0 END) AS male_count,
        CASE
        WHEN SUM(CASE WHEN SUBSTRING(e.first_name, 1, 1) BETWEEN 'N' AND 'Z' THEN 1 ELSE 0 END) = 0 THEN 0
        ELSE SUM(CASE WHEN SUBSTRING(e.first_name, 1, 1) BETWEEN 'A' AND 'M' THEN 1 ELSE 0 END) / SUM(CASE WHEN SUBSTRING(e.first_name, 1, 1) BETWEEN 'N' AND 'Z' THEN 1 ELSE 0 END)
        END AS ratio
        FROM departments d
        JOIN employees e ON d.dept_id = e.dept_id
        GROUP BY d.dept_id, d.dept_name;
45. 查询每个部门年龄最大和最小的员工(假设hire_date反应了年龄)。

        WITH RankedEmployees AS (
        SELECT
        e.emp_id,
        e.first_name,
        e.last_name,
        e.hire_date,
        d.dept_name,
        RANK() OVER (PARTITION BY d.dept_id ORDER BY e.hire_date) AS hire_date_rank_asc,
        RANK() OVER (PARTITION BY d.dept_id ORDER BY e.hire_date DESC) AS hire_date_rank_desc
        FROM employees e
        JOIN departments d ON e.dept_id = d.dept_id
        )
        SELECT dept_name,
        MIN_EMP.first_name AS min_age_first_name,
        MIN_EMP.last_name AS min_age_last_name,
        MIN_EMP.hire_date AS min_age_hire_date,
        MAX_EMP.first_name AS max_age_first_name,
        MAX_EMP.last_name AS max_age_last_name,
        MAX_EMP.hire_date AS max_age_hire_date
        FROM (
        SELECT dept_name, first_name, last_name, hire_date
        FROM RankedEmployees
        WHERE hire_date_rank_asc = 1
        ) AS MIN_EMP
        JOIN (
        SELECT dept_name, first_name, last_name, hire_date
        FROM RankedEmployees
        WHERE hire_date_rank_desc = 1
        ) AS MAX_EMP ON MIN_EMP.dept_name = MAX_EMP.dept_name;
46. 查询连续3天都有员工入职的日期。

        WITH HireDates AS (
        SELECT hire_date, ROW_NUMBER() OVER (ORDER BY hire_date) AS rn
        FROM employees
        ),
        ConsecutiveDates AS (
        SELECT h1.hire_date AS start_date, h3.hire_date AS end_date
        FROM HireDates h1
        JOIN HireDates h2 ON h2.rn = h1.rn + 1
        JOIN HireDates h3 ON h3.rn = h1.rn + 2
        WHERE DATEDIFF(h3.hire_date, h1.hire_date) = 2
        )
        SELECT start_date, end_date
        FROM ConsecutiveDates;
47. 查询员工姓名和他参与的项目数量。

        SELECT e.first_name, e.last_name, COUNT(ep.project_id) AS project_count
        FROM employees e
        LEFT JOIN employee_projects ep ON e.emp_id = ep.emp_id
        GROUP BY e.emp_id, e.first_name, e.last_name;
48. 查询每个部门工资最高的3名员工。

        WITH RankedEmployees AS (
        SELECT
        e.emp_id,
        e.first_name,
        e.last_name,
        e.salary,
        e.dept_id,
        DENSE_RANK() OVER (PARTITION BY e.dept_id ORDER BY e.salary DESC) AS salary_rank
        FROM employees e
        )
        SELECT re.emp_id, re.first_name, re.last_name, re.salary, re.dept_id
        FROM RankedEmployees re
        WHERE re.salary_rank <= 3;
49. 计算每个员工的工资与其所在部门平均工资的差值。

        SELECT
        e.emp_id,
        e.first_name,
        e.last_name,
        e.salary,
        d.dept_name,
        e.salary - AVG(e2.salary) OVER (PARTITION BY e.dept_id) AS salary_difference
        FROM
        employees e
        JOIN departments d ON e.dept_id = d.dept_id
        JOIN employees e2 ON e.dept_id = e2.dept_id;
50. 查询所有项目的信息,包括项目名称、负责人姓名(假设工资最高的为负责人)、开始日期和结束日期。

        SELECT p.project_name, e.first_name || ' ' || e.last_name AS manager_name, p.start_date, p.end_date
        FROM projects p
        JOIN (
        SELECT ep.project_id, e.emp_id, e.first_name, e.last_name
        FROM employee_projects ep
        JOIN (
        SELECT emp_id, first_name, last_name
        FROM employees
        WHERE salary = (SELECT MAX(salary) FROM employees)
        ) e ON ep.emp_id = e.emp_id
        ) e ON p.project_id = e.project_id;

# 作业
1.查询所有学生的信息。

    SELECT * FROM student;
2.查询所有课程的信息。

    SELECT * FROM course;
3.查询所有学生的姓名、学号和班级。

    SELECT name, student_id, my_class FROM student;
4.查询所有教师的姓名和职称。

    SELECT name, title FROM teacher;
5.查询不同课程的平均分数。

    SELECT course_id, AVG(score) FROM score GROUP BY course_id;
6.查询每个学生的平均分数。

    SELECT student_id, AVG(score) FROM score GROUP BY student_id;
7.查询分数大于85分的学生学号和课程号。

    SELECT student_id, course_id FROM score WHERE score > 85;
8.查询每门课程的选课人数。

    SELECT course_id, COUNT(*) FROM score GROUP BY course_id;
9.查询选修了"高等数学"课程的学生姓名和分数。

    SELECT s.name, sc.score
    FROM student s
    JOIN score sc ON s.student_id = sc.student_id
    JOIN course c ON sc.course_id = c.course_id
    WHERE c.course_name = '高等数学';
10.查询没有选修"大学物理"课程的学生姓名。

    SELECT s.name
    FROM student s
    WHERE s.student_id NOT IN (
    SELECT sc.student_id
    FROM score sc
    JOIN course c ON sc.course_id = c.course_id
    WHERE c.course_name = '大学物理'
    );
11.查询C001比C002课程成绩高的学生信息及课程分数。

    SELECT s.*, sc1.score AS AdvancedMath_score, sc2.score AS UniversityPhysics_score
    FROM student s
    JOIN score sc1 ON s.student_id = sc1.student_id AND sc1.course_id = 'C001'
    JOIN score sc2 ON s.student_id = sc2.student_id AND sc2.course_id = 'C002'
    WHERE sc1.score > sc2.score;
12.统计各科成绩各分数段人数：课程编号，课程名称，[100-85]，[85-70]，[70-60]，[60-0] 及所占百分比

    SELECT
    c.course_id,
    c.course_name,
    COUNT(CASE WHEN sc.score BETWEEN 85 AND 100 THEN 1 END) AS '100-85',
    COUNT(CASE WHEN sc.score BETWEEN 70 AND 84 THEN 1 END) AS '85-70',
    COUNT(CASE WHEN sc.score BETWEEN 60 AND 69 THEN 1 END) AS '70-60',
    COUNT(CASE WHEN sc.score < 60 THEN 1 END) AS '60-0',
    ROUND((COUNT(CASE WHEN sc.score BETWEEN 85 AND 100 THEN 1 END) / COUNT(sc.score)) * 100, 2) AS 'Percentage_100-85',
    ROUND((COUNT(CASE WHEN sc.score BETWEEN 70 AND 84 THEN 1 END) / COUNT(sc.score)) * 100, 2) AS 'Percentage_85-70',
    ROUND((COUNT(CASE WHEN sc.score BETWEEN 60 AND 69 THEN 1 END) / COUNT(sc.score)) * 100, 2) AS 'Percentage_70-60',
    ROUND((COUNT(CASE WHEN sc.score < 60 THEN 1 END) / COUNT(sc.score)) * 100, 2) AS 'Percentage_60-0'
    FROM score sc
    JOIN course c ON sc.course_id = c.course_id
    GROUP BY c.course_id;
13.查询选择C002课程但没选择C004课程的成绩情况(不存在时显示为 null )。

    SELECT
    s.name,
    sc.score AS C002_score,
    COALESCE(sc2.score, 'null') AS C004_score
    FROM
    score sc
    JOIN
    student s ON sc.student_id = s.student_id
    LEFT JOIN
    score sc2 ON sc.student_id = sc2.student_id AND sc2.course_id = 'C004'
    WHERE
    sc.course_id = 'C002'
    AND sc.student_id NOT IN (
    SELECT student_id
    FROM score
    WHERE course_id = 'C004'
    );
14.查询平均分数最高的学生姓名和平均分数。

    SELECT
    s.name,
    AVG(sc.score) AS average_score
    FROM
    student s
    JOIN
    score sc ON s.student_id = sc.student_id
    GROUP BY
    s.student_id, s.name
    ORDER BY
    average_score DESC
    LIMIT 1;
15.查询总分最高的前三名学生的姓名和总分。

    SELECT
    s.name,
    SUM(sc.score) AS total_score
    FROM
    student s
    JOIN
    score sc ON s.student_id = sc.student_id
    GROUP BY
    s.student_id, s.name
    ORDER BY
    total_score DESC
    LIMIT 3;
16.查询各科成绩最高分、最低分和平均分。要求如下：
以如下形式显示：课程 ID，课程 name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率
及格为>=60，中等为：70-80，优良为：80-90，优秀为：>=90
要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列

    SELECT
    c.course_id,
    c.course_name,
    MAX(sc.score) AS max_score,
    MIN(sc.score) AS min_score,
    AVG(sc.score) AS avg_score,
    SUM(CASE WHEN sc.score >= 60 THEN 1 ELSE 0 END) / COUNT(sc.score) AS pass_rate,
    SUM(CASE WHEN sc.score BETWEEN 70 AND 80 THEN 1 ELSE 0 END) / COUNT(sc.score) AS average_rate,
    SUM(CASE WHEN sc.score BETWEEN 80 AND 90 THEN 1 ELSE 0 END) / COUNT(sc.score) AS good_rate,
    SUM(CASE WHEN sc.score >= 90 THEN 1 ELSE 0 END) / COUNT(sc.score) AS excellent_rate,
    COUNT(sc.student_id) AS enrolled_students
    FROM
    course c
    JOIN
    score sc ON c.course_id = sc.course_id
    GROUP BY
    c.course_id, c.course_name
    ORDER BY
    COUNT(sc.student_id) DESC, c.course_id ASC;
17.查询男生和女生的人数。

    SELECT
    gender,
    COUNT(*) AS student_count
    FROM
    student
    GROUP BY
    gender;
18.查询年龄最大的学生姓名。

    SELECT
    name
    FROM
    student
    WHERE
    birth_date = (SELECT MIN(birth_date) FROM student);
19.查询年龄最小的教师姓名。

    SELECT
    name
    FROM
    teacher
    WHERE
    birth_date = (SELECT MAX(birth_date) FROM teacher);
20.查询学过「张教授」授课的同学的信息。

    SELECT
    s.*
    FROM
    student s
    JOIN
    score sc ON s.student_id = sc.student_id
    JOIN
    course c ON sc.course_id = c.course_id
    WHERE
    c.teacher_id = (SELECT teacher_id FROM teacher WHERE name = '张教授');
21.查询查询至少有一门课与学号为"2021001"的同学所学相同的同学的信息 。

    SELECT
    DISTINCT s.*
    FROM
    student s
    JOIN
    score sc ON s.student_id = sc.student_id
    WHERE
    sc.course_id IN (
    SELECT
    sc2.course_id
    FROM
    score sc2
    WHERE
    sc2.student_id = '2021001'
    )
    AND
    s.student_id <> '2021001';
22.查询每门课程的平均分数，并按平均分数降序排列。

    SELECT
    course_id,
    AVG(score) AS average_score
    FROM
    score
    GROUP BY
    course_id
    ORDER BY
    average_score DESC;
23.查询学号为"2021001"的学生所有课程的分数。

    SELECT
    course_id,
    score
    FROM
    score
    WHERE
    student_id = '2021001';
24.查询所有学生的姓名、选修的课程名称和分数。

    SELECT
    s.name AS student_name,
    c.course_name AS course_name,
    sc.score
    FROM
    student s
    JOIN
    score sc ON s.student_id = sc.student_id
    JOIN
    course c ON sc.course_id = c.course_id;
25.查询每个教师所教授课程的平均分数。

    SELECT
    t.name AS teacher_name,
    c.course_name AS course_name,
    AVG(sc.score) AS average_score
    FROM
    teacher t
    JOIN
    course c ON t.teacher_id = c.teacher_id
    JOIN
    score sc ON c.course_id = sc.course_id
    GROUP BY
    t.name, c.course_name;
26.查询分数在80到90之间的学生姓名和课程名称。

    SELECT
    s.name AS student_name,
    c.course_name AS course_name
    FROM
    student s
    JOIN
    score sc ON s.student_id = sc.student_id
    JOIN
    course c ON sc.course_id = c.course_id
    WHERE
    sc.score BETWEEN 80 AND 90;
27.查询每个班级的平均分数。

    SELECT
    s.my_class,
    AVG(sc.score) AS average_score
    FROM
    student s
    JOIN
    score sc on s.student_id = sc.student_id
    GROUP BY
    s.my_class;
28.查询没学过"王讲师"老师讲授的任一门课程的学生姓名。

    SELECT
    s.name AS student_name
    FROM
    student s
    WHERE
    s.student_id NOT IN (
    SELECT
    sc.student_id
    FROM
    score sc
    JOIN
    course c ON sc.course_id = c.course_id
    JOIN
    teacher t ON c.teacher_id = t.teacher_id
    WHERE
    t.name = '王讲师'
    );
29.查询两门及其以上小于85分的同学的学号，姓名及其平均成绩 。

    SELECT
    s.student_id,
    s.name,
    AVG(sc.score) AS average_score
    FROM
    student s
    JOIN
    score sc ON s.student_id = sc.student_id
    WHERE
    sc.score < 85
    GROUP BY
    s.student_id, s.name
    HAVING
    COUNT(sc.course_id) >= 2;
30.查询所有学生的总分并按降序排列。

    SELECT
    s.student_id,
    s.name,
    SUM(sc.score) AS total_score
    FROM
    student s
    JOIN
    score sc ON s.student_id = sc.student_id
    GROUP BY
    s.student_id, s.name
    ORDER BY
    total_score DESC;
31.查询平均分数超过85分的课程名称。

    SELECT
    c.course_name
    FROM
    course c
    JOIN
    score sc ON c.course_id = sc.course_id
    GROUP BY
    c.course_name
    HAVING
    AVG(sc.score) > 85;

32.查询每个学生的平均成绩排名。

    -- 创建临时表用于存储学生平均成绩及排名
    WITH StudentAverageScores AS (
    SELECT
    s.student_id,
    AVG(sc.score) AS average_score
    FROM
    student s
    JOIN score sc ON s.student_id = sc.student_id
    GROUP BY
    s.student_id
    ),
    RankedScores AS (
    SELECT
    student_id,
    average_score,
    -- 计算排名
    DENSE_RANK() OVER (ORDER BY average_score DESC) AS ranking
    FROM
    StudentAverageScores
    )
    SELECT
    s.name,
    rs.average_score,
    rs.ranking
    FROM
    student s
    JOIN RankedScores rs ON s.student_id = rs.student_id
    ORDER BY
    rs.ranking;
33.查询每门课程分数最高的学生姓名和分数。

    SELECT
    c.course_name,
    s.name AS student_name,
    sc.score AS highest_score
    FROM
    course c
    JOIN
    score sc ON c.course_id = sc.course_id
    JOIN
    student s ON sc.student_id = s.student_id
    WHERE
    (sc.course_id, sc.score) IN (
    SELECT
    sc.course_id,
    MAX(sc.score)
    FROM
    score sc
    GROUP BY
    sc.course_id
    )
    ORDER BY
    c.course_name,
    sc.score DESC;
34.查询选修了"高等数学"和"大学物理"的学生姓名。

    SELECT
    s.name
    FROM
    student s
    JOIN score sc1 ON s.student_id = sc1.student_id
    JOIN score sc2 ON s.student_id = sc2.student_id
    JOIN course c1 ON sc1.course_id = c1.course_id
    JOIN course c2 ON sc2.course_id = c2.course_id
    WHERE
    c1.course_name = '高等数学'
    AND c2.course_name = '大学物理';
35.按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩（没有选课则为空）。

    SELECT
    s.student_id,
    s.name,
    c.course_name,
    sc.score,
    -- 计算每个学生的平均成绩，使用 COALESCE 处理 NULL 值
    AVG(COALESCE(sc.score, 0)) OVER (PARTITION BY s.student_id) AS average_score
    FROM
    student s
    CROSS JOIN course c -- 生成学生和课程的笛卡尔积
    LEFT JOIN score sc ON s.student_id = sc.student_id AND c.course_id = sc.course_id
    ORDER BY
    average_score DESC, s.student_id, c.course_name;
36.查询分数最高和最低的学生姓名及其分数。

    -- 查询分数最高的学生姓名和分数
    WITH MaxScore AS (
    SELECT
    s.student_id,
    s.name,
    sc.score AS max_score
    FROM
    student s
    JOIN score sc ON s.student_id = sc.student_id
    WHERE
    sc.score = (SELECT MAX(score) FROM score)
    ),
    MinScore AS (
    SELECT
    s.student_id,
    s.name,
    sc.score AS min_score
    FROM
    student s
    JOIN score sc ON s.student_id = sc.student_id
    WHERE
    sc.score = (SELECT MIN(score) FROM score)
    )
    SELECT
    '最高分学生',
    ms.name,
    ms.max_score
    FROM
    MaxScore ms
    UNION ALL
    SELECT
    '最低分学生',
    mins.name,
    mins.min_score
    FROM
    MinScore mins;
37.查询每个班级的最高分和最低分。

    SELECT
    s.my_class AS class_name,
    MAX(sc.score) AS max_score,
    MIN(sc.score) AS min_score
    FROM
    student s
    JOIN score sc ON s.student_id = sc.student_id
    GROUP BY
    s.my_class;
38.查询每门课程的优秀率（优秀为90分）。

    SELECT
    c.course_name,
    -- 计算优秀人数
    SUM(CASE WHEN sc.score >= 90 THEN 1 ELSE 0 END) / COUNT(sc.student_id) AS excellent_rate
    FROM
    course c
    JOIN score sc ON c.course_id = sc.course_id
    GROUP BY
    c.course_id;
39.查询平均分数超过班级平均分数的学生。

    -- 计算每个班级的平均分数
    WITH ClassAverages AS (
    SELECT
    s.my_class,
    AVG(sc.score) AS class_avg_score
    FROM
    student s
    JOIN score sc ON s.student_id = sc.student_id
    GROUP BY
    s.my_class
    )
    -- 计算每个学生的平均分数，并与班级平均分数进行比较
    SELECT
    s.student_id,
    s.name,
    s.my_class,
    AVG(sc.score) AS student_avg_score,
    ca.class_avg_score
    FROM
    student s
    JOIN score sc ON s.student_id = sc.student_id
    JOIN ClassAverages ca ON s.my_class = ca.my_class
    GROUP BY
    s.student_id, s.name, s.my_class, ca.class_avg_score
    HAVING
    AVG(sc.score) > ca.class_avg_score;
40.查询每个学生的分数及其与课程平均分的差值。

    SELECT
    s.student_id,
    s.name,
    c.course_name,
    sc.score,
    sc.score - AVG(sc.score) OVER (PARTITION BY c.course_id) AS difference_from_course_avg
    FROM
    student s
    JOIN score sc ON s.student_id = sc.student_id
    JOIN course c ON sc.course_id = c.course_id;
41.查询至少有一门课程分数低于80分的学生姓名。

    SELECT
    s.name
    FROM
    student s
    WHERE
    EXISTS (
    SELECT
    1
    FROM
    score sc
    WHERE
    sc.student_id = s.student_id
    AND sc.score < 80
    );
42.查询所有课程分数都高于85分的学生姓名。

    SELECT
    s.name
    FROM
    student s
    WHERE
    NOT EXISTS (
    SELECT
    1
    FROM
    score sc
    WHERE
    sc.student_id = s.student_id
    AND sc.score <= 85
    );
43.查询查询平均成绩大于等于90分的同学的学生编号和学生姓名和平均成绩。

    SELECT
    s.student_id,
    s.name,
    AVG(sc.score) AS average_score
    FROM
    student s
    JOIN score sc ON s.student_id = sc.student_id
    GROUP BY
    s.student_id, s.name
    HAVING
    AVG(sc.score) >= 90;
44.查询选修课程数量最少的学生姓名。

    -- 1. 首先使用子查询找出每个学生选修课程的数量
    WITH StudentCourseCount AS (
    SELECT
    sc.student_id,
    COUNT(sc.course_id) AS course_count
    FROM
    score sc
    GROUP BY
    sc.student_id
    )
    -- 2. 再找出课程数量最少的值
    SELECT
    s.name
    FROM
    student s
    JOIN StudentCourseCount scc ON s.student_id = scc.student_id
    WHERE
    scc.course_count = (SELECT MIN(course_count) FROM StudentCourseCount);
45.查询每个班级的第2名学生（按平均分数排名）。

    -- 1. 首先使用子查询计算每个学生的平均分数以及在班级中的排名
    WITH RankedStudents AS (
    SELECT
    s.student_id,
    s.name,
    s.my_class,
    AVG(sc.score) AS average_score,
    DENSE_RANK() OVER (PARTITION BY s.my_class ORDER BY AVG(sc.score) DESC) AS ranking
    FROM
    student s
    JOIN score sc ON s.student_id = sc.student_id
    GROUP BY
    s.student_id, s.name, s.my_class
    )
    -- 2. 然后从这个结果中筛选出排名为 2 的学生
    SELECT
    rs.name,
    rs.my_class,
    rs.average_score
    FROM
    RankedStudents rs
    WHERE
    rs.ranking = 2;
46.查询每门课程分数前三名的学生姓名和分数。

    -- 使用公共表达式（CTE）为每门课程的分数分配排名
    WITH RankedScores AS (
    SELECT
    sc.student_id,
    s.name,
    sc.course_id,
    sc.score,
    DENSE_RANK() OVER (PARTITION BY sc.course_id ORDER BY sc.score DESC) AS ranking
    FROM
    score sc
    JOIN student s ON sc.student_id = s.student_id
    )
    -- 从 CTE 中选择排名前三的记录
    SELECT
    rs.course_id,
    rs.name,
    rs.score
    FROM
    RankedScores rs
    WHERE
    rs.ranking <= 3;
47.查询平均分数最高和最低的班级。

    -- 1. 首先使用子查询计算每个班级的平均分数
    WITH ClassAverages AS (
    SELECT
    s.my_class,
    AVG(sc.score) AS average_score
    FROM
    student s
    JOIN score sc ON s.student_id = sc.student_id
    GROUP BY
    s.my_class
    )
    -- 2. 找出平均分数最高的班级
    SELECT
    '最高平均分班级',
    ca.my_class,
    ca.average_score
    FROM
    ClassAverages ca
    WHERE
    ca.average_score = (SELECT MAX(average_score) FROM ClassAverages);
    
    -- 3. 找出平均分数最低的班级
    SELECT
    '最低平均分班级',
    ca.my_class,
    ca.average_score
    FROM
    ClassAverages ca
    WHERE
    ca.average_score = (SELECT MIN(average_score) FROM ClassAverages);
48.查询每个学生的总分和他所在班级的平均分数。

    -- 1. 使用公共表达式（CTE）计算每个学生的总分
    WITH StudentTotals AS (
    SELECT
    s.student_id,
    s.name,
    s.my_class,
    SUM(sc.score) AS total_score
    FROM
    student s
    JOIN score sc ON s.student_id = sc.student_id
    GROUP BY
    s.student_id, s.name, s.my_class
    )
    -- 2. 再计算每个班级的平均分数，并与学生信息进行连接
    SELECT
    st.student_id,
    st.name,
    st.my_class,
    st.total_score,
    ca.class_avg_score
    FROM
    StudentTotals st
    JOIN (
    SELECT
    my_class,
    AVG(total_score) AS class_avg_score
    FROM
    StudentTotals
    GROUP BY
    my_class
    ) ca ON st.my_class = ca.my_class;
49.查询每个学生的最高分的课程名称, 学生名称，成绩。

    SELECT
    s.name AS student_name,
    c.course_name,
    sc.score AS highest_score
    FROM
    student s
    JOIN
    score sc ON s.student_id = sc.student_id
    JOIN
    course c ON sc.course_id = c.course_id
    WHERE
    sc.score = (
    SELECT
    MAX(sub.score)
    FROM
    score sub
    WHERE
    sub.student_id = s.student_id
    )
    ORDER BY
    s.name,
    c.course_name;
50.查询每个班级的学生人数和平均年龄。

    SELECT
    s.my_class AS class_name,
    COUNT(s.student_id) AS student_count,
    AVG(TIMESTAMPDIFF(YEAR, s.birth_date, CURDATE())) AS average_age
    FROM
    student s
    GROUP BY
    s.my_class;